package docs

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"

	"github.com/nohdol/claude-auto/pkg/types"
	"github.com/rs/zerolog"
)

// DocGenerator generates project documentation
type DocGenerator struct {
	outputDir string
	language  string
	logger    zerolog.Logger
}

// NewDocGenerator creates a new documentation generator
func NewDocGenerator(outputDir, language string, logger zerolog.Logger) *DocGenerator {
	return &DocGenerator{
		outputDir: outputDir,
		language:  language,
		logger:    logger,
	}
}

// GenerateProgressReport generates a progress report document
func (dg *DocGenerator) GenerateProgressReport(doc *types.ProgressDocument) error {
	// Ensure output directory exists
	if err := os.MkdirAll(dg.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate filename with date
	filename := fmt.Sprintf("progress_%s.md", doc.Date.Format("2006-01-02_15-04"))
	filepath := filepath.Join(dg.outputDir, filename)

	// Render template
	content, err := dg.renderProgressTemplate(doc)
	if err != nil {
		return fmt.Errorf("failed to render template: %w", err)
	}

	// Write to file
	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	dg.logger.Info().
		Str("file", filepath).
		Msg("Progress report generated")

	return nil
}

// renderProgressTemplate renders the progress report template
func (dg *DocGenerator) renderProgressTemplate(doc *types.ProgressDocument) (string, error) {
	tmpl := template.New("progress")
	tmpl, err := tmpl.Parse(progressTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, doc); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// GenerateREADME generates a README file for the project
func (dg *DocGenerator) GenerateREADME(projectName, description string, features []string) error {
	data := struct {
		ProjectName string
		Description string
		Features    []string
		GeneratedAt time.Time
	}{
		ProjectName: projectName,
		Description: description,
		Features:    features,
		GeneratedAt: time.Now(),
	}

	tmpl := template.New("readme")
	tmpl, err := tmpl.Parse(readmeTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	readmePath := filepath.Join(filepath.Dir(dg.outputDir), "README.md")
	if err := os.WriteFile(readmePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README: %w", err)
	}

	dg.logger.Info().
		Str("file", readmePath).
		Msg("README generated")

	return nil
}

// UpdateMetrics updates project metrics in the documentation
func (dg *DocGenerator) UpdateMetrics(metrics *ProjectMetrics) error {
	metricsFile := filepath.Join(dg.outputDir, "metrics.json")

	// For now, we'll just log the metrics
	dg.logger.Info().
		Int("lines_of_code", metrics.LinesOfCode).
		Int("commit_count", metrics.CommitCount).
		Float64("test_coverage", metrics.TestCoverage).
		Msg("Metrics updated")

	return nil
}

// ProjectMetrics represents project metrics
type ProjectMetrics struct {
	LinesOfCode  int
	CommitCount  int
	TestCoverage float64
	BuildTime    time.Duration
}

// Template definitions
const progressTemplate = `# 프로젝트 진행 상황 보고서

## 📅 날짜: {{.Date.Format "2006-01-02 15:04"}}
## 📊 현재 단계: {{.Phase}}

## ✅ 완료된 작업
{{range .CompletedTasks}}
### {{.Type}}: {{.Title}}
- 시작: {{.StartTime.Format "15:04:05"}}
{{if .EndTime}}- 완료: {{.EndTime.Format "15:04:05"}}{{end}}
{{if .Duration}}- 소요 시간: {{.Duration}}{{end}}
- 결과: {{.Result}}
{{end}}

## 🔄 진행 중인 작업
{{range .InProgressTasks}}
### {{.Type}}: {{.Title}}
- 시작: {{.StartTime.Format "15:04:05"}}
{{if .EstimatedTime}}- 예상 완료: {{.EstimatedTime.Format "15:04:05"}}{{end}}
{{end}}

## 📈 메트릭
- 전체 진행률: {{printf "%.1f" .Progress}}%
- 코드 라인: {{.LinesOfCode}}
- 커밋 수: {{.CommitCount}}
- 테스트 커버리지: {{printf "%.1f" .TestCoverage}}%

## 🔑 API 키 상태
{{range .APIKeys}}
- {{.Name}}: {{if .Configured}}✅{{else}}❌{{end}}
{{end}}

## 🚀 다음 단계
{{range .NextSteps}}
1. {{.}}
{{end}}

---
*Generated by Claude Auto-Deploy CLI*
`

const readmeTemplate = `# {{.ProjectName}}

{{.Description}}

## 🚀 Features

{{range .Features}}
- {{.}}
{{end}}

## 📦 Installation

\`\`\`bash
# Clone the repository
git clone https://github.com/yourusername/{{.ProjectName}}.git

# Navigate to project directory
cd {{.ProjectName}}

# Install dependencies
npm install
# or
yarn install
\`\`\`

## 🔧 Configuration

Create a \`.env\` file based on \`.env.example\`:

\`\`\`bash
cp .env.example .env
\`\`\`

Update the environment variables as needed.

## 🏃 Running the Application

### Development
\`\`\`bash
npm run dev
# or
yarn dev
\`\`\`

### Production
\`\`\`bash
npm run build
npm start
# or
yarn build
yarn start
\`\`\`

## 🧪 Testing

\`\`\`bash
npm test
# or
yarn test
\`\`\`

## 📝 API Documentation

API documentation is available at \`/api/docs\` when running the application.

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (\`git checkout -b feature/AmazingFeature\`)
3. Commit your changes (\`git commit -m 'Add some AmazingFeature'\`)
4. Push to the branch (\`git push origin feature/AmazingFeature\`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- Generated by [Claude Auto-Deploy CLI](https://github.com/nohdol/claude-auto)
- Built with ❤️ using AI-powered development

---
*Generated on {{.GeneratedAt.Format "2006-01-02"}}*
`