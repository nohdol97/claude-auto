package docs

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"

	"github.com/nohdol/claude-auto/pkg/types"
	"github.com/rs/zerolog"
)

// DocGenerator generates project documentation
type DocGenerator struct {
	outputDir string
	language  string
	logger    zerolog.Logger
}

// NewDocGenerator creates a new documentation generator
func NewDocGenerator(outputDir, language string, logger zerolog.Logger) *DocGenerator {
	return &DocGenerator{
		outputDir: outputDir,
		language:  language,
		logger:    logger,
	}
}

// GenerateProgressReport generates a progress report document
func (dg *DocGenerator) GenerateProgressReport(doc *types.ProgressDocument) error {
	// Ensure output directory exists
	if err := os.MkdirAll(dg.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate filename with date
	filename := fmt.Sprintf("progress_%s.md", doc.Date.Format("2006-01-02_15-04"))
	filepath := filepath.Join(dg.outputDir, filename)

	// Render template
	content, err := dg.renderProgressTemplate(doc)
	if err != nil {
		return fmt.Errorf("failed to render template: %w", err)
	}

	// Write to file
	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	dg.logger.Info().
		Str("file", filepath).
		Msg("Progress report generated")

	return nil
}

// renderProgressTemplate renders the progress report template
func (dg *DocGenerator) renderProgressTemplate(doc *types.ProgressDocument) (string, error) {
	tmpl := template.New("progress")
	tmpl, err := tmpl.Parse(progressTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, doc); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// GenerateREADME generates a README file for the project
func (dg *DocGenerator) GenerateREADME(projectName, description string, features []string) error {
	data := struct {
		ProjectName string
		Description string
		Features    []string
		GeneratedAt time.Time
	}{
		ProjectName: projectName,
		Description: description,
		Features:    features,
		GeneratedAt: time.Now(),
	}

	tmpl := template.New("readme")
	tmpl, err := tmpl.Parse(readmeTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	readmePath := filepath.Join(filepath.Dir(dg.outputDir), "README.md")
	if err := os.WriteFile(readmePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README: %w", err)
	}

	dg.logger.Info().
		Str("file", readmePath).
		Msg("README generated")

	return nil
}

// UpdateMetrics updates project metrics in the documentation
func (dg *DocGenerator) UpdateMetrics(metrics *ProjectMetrics) error {
	metricsFile := filepath.Join(dg.outputDir, "metrics.json")

	// For now, we'll just log the metrics
	dg.logger.Info().
		Int("lines_of_code", metrics.LinesOfCode).
		Int("commit_count", metrics.CommitCount).
		Float64("test_coverage", metrics.TestCoverage).
		Msg("Metrics updated")

	return nil
}

// ProjectMetrics represents project metrics
type ProjectMetrics struct {
	LinesOfCode  int
	CommitCount  int
	TestCoverage float64
	BuildTime    time.Duration
}

// Template definitions
const progressTemplate = `# í”„ë¡œì íŠ¸ ì§„í–‰ ìƒí™© ë³´ê³ ì„œ

## ğŸ“… ë‚ ì§œ: {{.Date.Format "2006-01-02 15:04"}}
## ğŸ“Š í˜„ì¬ ë‹¨ê³„: {{.Phase}}

## âœ… ì™„ë£Œëœ ì‘ì—…
{{range .CompletedTasks}}
### {{.Type}}: {{.Title}}
- ì‹œì‘: {{.StartTime.Format "15:04:05"}}
{{if .EndTime}}- ì™„ë£Œ: {{.EndTime.Format "15:04:05"}}{{end}}
{{if .Duration}}- ì†Œìš” ì‹œê°„: {{.Duration}}{{end}}
- ê²°ê³¼: {{.Result}}
{{end}}

## ğŸ”„ ì§„í–‰ ì¤‘ì¸ ì‘ì—…
{{range .InProgressTasks}}
### {{.Type}}: {{.Title}}
- ì‹œì‘: {{.StartTime.Format "15:04:05"}}
{{if .EstimatedTime}}- ì˜ˆìƒ ì™„ë£Œ: {{.EstimatedTime.Format "15:04:05"}}{{end}}
{{end}}

## ğŸ“ˆ ë©”íŠ¸ë¦­
- ì „ì²´ ì§„í–‰ë¥ : {{printf "%.1f" .Progress}}%
- ì½”ë“œ ë¼ì¸: {{.LinesOfCode}}
- ì»¤ë°‹ ìˆ˜: {{.CommitCount}}
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€: {{printf "%.1f" .TestCoverage}}%

## ğŸ”‘ API í‚¤ ìƒíƒœ
{{range .APIKeys}}
- {{.Name}}: {{if .Configured}}âœ…{{else}}âŒ{{end}}
{{end}}

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„
{{range .NextSteps}}
1. {{.}}
{{end}}

---
*Generated by Claude Auto-Deploy CLI*
`

const readmeTemplate = `# {{.ProjectName}}

{{.Description}}

## ğŸš€ Features

{{range .Features}}
- {{.}}
{{end}}

## ğŸ“¦ Installation

\`\`\`bash
# Clone the repository
git clone https://github.com/yourusername/{{.ProjectName}}.git

# Navigate to project directory
cd {{.ProjectName}}

# Install dependencies
npm install
# or
yarn install
\`\`\`

## ğŸ”§ Configuration

Create a \`.env\` file based on \`.env.example\`:

\`\`\`bash
cp .env.example .env
\`\`\`

Update the environment variables as needed.

## ğŸƒ Running the Application

### Development
\`\`\`bash
npm run dev
# or
yarn dev
\`\`\`

### Production
\`\`\`bash
npm run build
npm start
# or
yarn build
yarn start
\`\`\`

## ğŸ§ª Testing

\`\`\`bash
npm test
# or
yarn test
\`\`\`

## ğŸ“ API Documentation

API documentation is available at \`/api/docs\` when running the application.

## ğŸ¤ Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (\`git checkout -b feature/AmazingFeature\`)
3. Commit your changes (\`git commit -m 'Add some AmazingFeature'\`)
4. Push to the branch (\`git push origin feature/AmazingFeature\`)
5. Open a Pull Request

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- Generated by [Claude Auto-Deploy CLI](https://github.com/nohdol/claude-auto)
- Built with â¤ï¸ using AI-powered development

---
*Generated on {{.GeneratedAt.Format "2006-01-02"}}*
`